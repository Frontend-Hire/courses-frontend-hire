import { FileTree, Callout } from 'nextra/components';

# Building Code Editor

Though the title says "Building Code Editor," we would do more of an "Assembling Code Editor."

Code Editors are extremely challenging to build from scratch, and there is no reason for anyone to create something like that from scratch. There are three great open-source options:

- [**Ace**](https://ace.c9.io/): The editor that powers Cloud9 IDE. It is a great editor that powers many online code editors. It is a bit old and not as actively maintained as it used to be.

- [**Monaco Editor**](https://github.com/microsoft/monaco-editor): The editor that powers VSCode. This course will use the [React wrapper](https://github.com/suren-atoyan/monaco-react).

- [**CodeMirror**](https://codemirror.net/): A minimalist code editor that is highly extensible. We use this on the Frontend Hire coding workspace.

All the editors are great, and you can use any of them. This course will use Monaco Editor. We use CodeMirror on the Frontend Hire coding workspace because it is lightweight and feels cleaner for practicing coding. We did not use Ace to have much of an opinion on it.

You can read more about the differences between the editors [Ace, CodeMirror, and Monaco: A Comparison of the Code Editors You Use in the Browser](https://blog.replit.com/code-editors). It is an excellent comparison from Faris Masad at Replit.

## Setting Up Monaco Editor

As mentioned, we will use the [React wrapper for Monaco Editor](https://github.com/suren-atoyan/monaco-react).

Let us install it:

```bash
npm install @monaco-editor/react
```

Let us create a component called `CodeEditor.tsx` to render the code editor and other things like the files tab. We will place this component in the `components` folder inside its folder `CodeEditor`, do a barrel export, and render it in our `App.tsx`. [Joshua Comeau's Delightful React File Structure](https://www.joshwcomeau.com/react/file-structure/) inspired this structure.

```tsx filename="src/components/CodeEditor/CodeEditor.tsx" showLineNumbers {1-3}
export default function CodeEditor() {
  return <div className='h-full border bg-red-100'>Code Editor</div>;
}
```

```tsx filename="src/components/CodeEditor/index.ts" showLineNumbers {1-3}
export * from './CodeEditor';

export { default } from './CodeEditor';
```

```tsx filename="src/App.tsx" showLineNumbers {2, 11}
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import CodeEditor from './components/CodeEditor';

export default function App() {
  return (
    <div className='h-dvh p-2'>
      <PanelGroup direction='horizontal'>
        <Panel>
          <PanelGroup direction='vertical'>
            <Panel>
              <CodeEditor />
            </Panel>
            <PanelResizeHandle className='h-2 bg-blue-300' />
            <Panel>
              <div className='h-full border bg-red-100'>Terminal</div>
            </Panel>
          </PanelGroup>
        </Panel>
        <PanelResizeHandle className='w-2 bg-blue-300' />
        <Panel>
          <div className='h-full border bg-red-100'>Preview</div>
        </Panel>
      </PanelGroup>
    </div>
  );
}
```

We will now render the Monaco Editor in the `CodeEditor` component.

```tsx filename="src/components/CodeEditor/CodeEditor.tsx" showLineNumbers {1, 5, 6}
import { Editor } from '@monaco-editor/react';

export default function CodeEditor() {
  return (
    <div className='h-full'>
      <Editor theme='vs-dark' />
    </div>
  );
}
```

The `Editor` component takes a `theme` prop. We set it to `vs-dark` to use the dark theme. You can set it to `light` or omit it for the light theme.

The editor now renders, but we must use the [multi-modal editor](https://github.com/suren-atoyan/monaco-react?tab=readme-ov-file#multi-model-editor) to support different files and languages. Before we do that, let us think about how we want to set up our code template.

## Thinking our Code Template

<Callout type='warning' emoji='⚠️'>
  WebContainer API has its [own
  way](https://webcontainers.io/guides/working-with-the-file-system) of working
  with files and folders; ideally, we would like to use a structure that mimics
  it. We will do the refactor in the next section when we integrate the
  WebContainer API. We know this because we did a POC with the API and have read
  the documentation well enough. We are not doing it now because the code editor
  is a complex component, and we want to understand it first before adding the
  WebContainer API.
</Callout>

In this course, we will only support React with Vite support. The files would take a top-level structure like the one below:

<FileTree>
  <FileTree.File name='App.jsx' />
  <FileTree.File name='index.jsx' />
  <FileTree.File name='index.html' />
  <FileTree.File name='package.json' />
  <FileTree.File name='vite.config.js' />
</FileTree>

We can use an object to represent the files. The keys would be the file names, and the value would be another object holding more information about the file, such as the contents. We could add more properties like `readOnly` and `hidden` to control the file's behavior in the editor. But for now, let us keep it simple with just the `contents` property.

The types would look like this:

```ts
type CodeFile = {
  contents: string;
};

type Template = {
  files: Record<string, CodeFile>;
  entry: string;
  visibleFiles: string[];
};
```

We use CodeFile instead of File to represent the file to avoid conflicts with the [File Interface](https://developer.mozilla.org/en-US/docs/Web/API/File) in JavaScript. We use a Template to describe the code template. We are also not using an array for the files because we want to access the files by their names.

Next up is the actual template. We will create a `templates` folder in the `src` folder and place the template in a file called `react-vite.ts` along with the types.

```ts filename="src/templates/react-vite.ts" showLineNumbers {1-83}
type CodeFile = {
  contents: string;
};

type Template = {
  files: Record<string, CodeFile>;
  entry: string;
  visibleFiles: string[];
};

export const VITE_REACT_TEMPLATE: Template = {
  files: {
    'App.jsx': {
      contents: `export default function App() {
  const data = "world"

  return <h1>Hello {data}</h1>
}
`,
    },

    'index.jsx': {
      contents: `import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);`,
    },

    'index.html': {
      contents: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.jsx"></script>
  </body>
</html>
`,
    },

    'package.json': {
      contents: `{
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview"
    },
    "dependencies": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0"
    },
    "devDependencies": {
        "@vitejs/plugin-react": "3.1.0",
        "vite": "4.1.4",
        "esbuild-wasm": "0.17.12"
    }
}`,
    },
    'vite.config.js': {
      contents: `import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});
`,
    },
  },
  entry: 'App.jsx',
  visibleFiles: ['App.jsx', 'index.jsx', 'index.html'],
};
```

Now, let us use the template and try to populate our multi-modal editor.

```tsx filename="src/components/CodeEditor/CodeEditor.tsx" showLineNumbers {3, 6-8, 10, 14-15}
import React from 'react';
import { Editor } from '@monaco-editor/react';
import { VITE_REACT_TEMPLATE } from '../../templates/react-vite';

export default function CodeEditor() {
  const [activeFile, setActiveFile] = React.useState(
    () => VITE_REACT_TEMPLATE.entry
  );

  const currentFile = VITE_REACT_TEMPLATE.files[activeFile];

  return (
    <div className='h-full'>
      <Editor
        theme='vs-dark'
        path={activeFile}
        defaultValue={currentFile.contents}
      />
    </div>
  );
}
```

The `path` prop is what enables this multi-modal editor. It tells the editor which files it is editing. The `defaultValue` prop sets the initial value of the editor. We use the `activeFile` state to keep track of the active file. We set it to the `entry` property of the template to start with the entry file.

We also derive the `currentFile` from the `activeFile` to get the current file's contents. We use this to set the editor's default (initial) value. But how do we switch between files? We will add a files tab to the editor's top to switch between files.

## Adding Files Tab
